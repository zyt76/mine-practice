<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>jQuery中对AJAX的封装</title>
    <script src="./jquery-1.12.4.js"></script>
</head>
<body>
    
</body>
<script>
    // // 最基础的调用
    // $.ajax('./time.php', {
    //     type: 'POST',// method 请求方法
    //     success: function (res) {
    //         // res => 拿到的只是响应体
    //         console.log(res);
    //     }
    // })

    // $.ajax({
    //     url: 'time.php',
    //     type: 'get',
    //     data: {id: 1, name: 'zs'},
    //     // 用于提交到服务端的参数,
    //     // 如果是 GET 请求就通过 url 地址传递
    //     // 如果是 POST 请求就通过请求体传递
    //     success: function (res) {
    //         console.log(res);
    //     }
    // })

    // $.ajax({
    //     url: 'json.php',
    //     type: 'get',
    //     data: {id: 1, name: 'zs'},
    //     // 用于提交到服务端的参数,
    //     // 如果是 GET 请求就通过 url 地址传递
    //     // 如果是 POST 请求就通过请求体传递
    //     success: function (res) {
    //         // res 会自动根据服务端响应的 content-type 自动转换为对象
    //         // 这是 jQuery 内部实现的
    //         console.log(res);
    //     }
    // })

    $.ajax({
        url: 'json.php',
        type: 'get',
        data: {id: 1, name: 'zs'},
        // 用于提交到服务端的参数,
        // 如果是 GET 请求就通过 url 地址传递
        // 如果是 POST 请求就通过请求体传递
        dataType: 'json',
        // 用于设置响应体的类型, 注意跟 data 参数没关系
        // 一旦设置了 dataType 之后, 就不再关心服务端响应的Content-Type 了
        success: function (res) {
            // res 会自动根据服务端响应的 content-type 自动转换为对象
            // 这是 jQuery 内部实现的
            console.log(res);
        }
    })
</script>
</html>